const csvParser = require('csv-parser');
const path = require('path');
const JSZip = require('jszip');
const fs = require('fs');
const { promisify } = require('util');

// The fs.readFile function, which would normally take a callback, can now be used with promises. 
// This allows you to use readFileAsync with async/await or with promise methods instead of callbacks. 
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);

const TEMPLATE_PATH = 'quote-template.docx';
const CSV_PATH = 'quote-data.csv';
const OUTPUT_FOLDER = 'output/';

// Create a directory
// The {recursive: true} option indicates that intermediate directories should be created if they do not exist. 
//      In this example it is not necessary, but for example if the output is "word/output/" it would be.
fs.mkdirSync(OUTPUT_FOLDER, { recursive: true });

// Reads the file asynchronously and waits for the operation to complete. 
// Once the operation completes, the contents of the file are returned as a result of the readFile function.
async function readFile(filePath) {
  try {
    return await readFileAsync(filePath);
  } catch (error) {
    throw new Error(`Error reading file ${filePath}: ${error.message}`);
  }
}

// Writes to the file asynchronously and waits for the operation to complete. 
// Once the operation completes, the function terminates without returning any value.
async function writeFile(filePath, data) {
  try {
    await writeFileAsync(filePath, data);
  } catch (error) {
    throw new Error(`Error writing file ${filePath}: ${error.message}`);
  }
}

// Function to replace placeholders in a string
//      content: text string containing placeholders in the form of {key}
//      data: is an object containing key-value pairs where the keys match the placeholders
function replacePlaceholders(content, data) {
  // Loops through all the keys of the data object using Object.entries(data), 
  //    which returns an array of [key, value] pairs.
  for (const [key, value] of Object.entries(data)) {
    const placeholder = `{${key}}`;
    // Finds all instances of that placeholder in content and replaces it with 
    //      the corresponding value from the data object.
    // RexExp: regular expression with the placeholder as the search pattern and the 'g' flag to do global matching, 
    //      meaning it will find and replace all occurrences of the placeholder in content.
    content = content.replace(new RegExp(placeholder, 'g'), value);
  }
  // Returns the string content with all placeholders replaced by their corresponding values 
  //        ​​from the data object.
  return content;
}

// Function to format number as currency
function formatCurrency(number) {
  // The toLocaleString() method of the Number object converts the number to a string
  //    minimumFractionDigits and maximumFractionDigits: Specify the minimum and maximum number 
  //      of decimal digits that should be displayed. In this case, it is set to 2.
  //    The 'en-US' code is used to indicate that the language and country format should be used. 
  //       In this case English and the United States.
  return '$' + number.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
}

// Read the CSV file and process each record
//    A reading stream of a CSV file is created
//    Process the contents of the CSV file efficiently and in real time, without needing to load the entire file into memory at once.
fs.createReadStream(CSV_PATH)
  // pipe() takes the read stream and connects it to another data stream that is generated by csvParser({ separator: ';' }
  // Each time the read stream emits data (that is, each time a line is read from the CSV file), 
  //    that data is passed to the CSV parser for processing.
  // csvParser({ separator: ';' }) is a function that parses the contents of the CSV file and splits each line into fields using the delimiter ;
  .pipe(csvParser({ separator: ';' }))
  // Sets an "event listener" on the data stream. In this case, the event being listened to is the 'data' event, 
  //    which is emitted every time a chunk of data is read from the data stream.
  // When the 'data' event is emitted, an asynchronous function is executed that receives the data fragment 
  //    read as an argument. In this context, data represents a line of data from the CSV file being processed.
  .on('data', async (data) => {
    try {
      // Verify that the information to be used is available
      if (!data['COMPANY-NAME']       || !data['BUDGET-NUMBER'] || !data['COMPANY-ADDRESS']  ||
          !data['DAYS-OF-VALIDITY']   || !data['DESCRIPTION']  || !data['AMOUNT']) {
        console.error('Skipping record: Missing COMPANY-NAME or BUDGET-NUMBER');
        return;
      }

      // Format {AMOUNT} as currency
      const amount = parseFloat(data['AMOUNT']);
      const formattedAmount = formatCurrency(amount);

      // Asynchronously reads the contents of the Word template file (template)
      const templatePath = path.join(__dirname, TEMPLATE_PATH);
      const templateContent = await readFile(templatePath);

      // Load the template as a zip file
      // The .docx format is a compressed file that contains several internal files and directories that
      //     make up the Word document. These files and directories are structured according to the 
      //    Open Packaging Conventions (OPC) standard, which is a zip file-based format. 
      //    For this reason, JSZip is used to load the content of the file, decompressing it and allowing 
      //    access to the internal files, such as the document content, styles, images, etc.
      const zip = await JSZip.loadAsync(templateContent);

      // Loads the contents of the document.xml file found inside the unzipped .docx file into a .docx file; 
      //    document.xml is the file that contains the main content of the document, including text, styles, 
      //    and other formatting elements.
      let docContent = await zip.file('word/document.xml').async('string');

      // Replace {BUDGET-NUMBER} with the value from the CSV data
      const budgetNumber = `<w:r><w:rPr><w:b/></w:rPr><w:t>${data['BUDGET-NUMBER']}</w:t></w:r>`;
      docContent = docContent.replace('{BUDGET-NUMBER}', budgetNumber);
      
      // Replace {DATE} with the current date in DD-MM-YYYY format
      const currentDate = new Date();
      const formattedDate = currentDate.toLocaleDateString('en-US', 
          //These options ensure that the date is formatted in the format DD-MM-YYYY,
          {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
          }
      );
      docContent = docContent.replace('{DATE}', formattedDate);

      // Replace {AMOUNT} with the formatted amount
      docContent = docContent.replace('{AMOUNT}', formattedAmount);

      // Replace other placeholders with data
      docContent = replacePlaceholders(docContent, data);

      // The content of the document within the ZIP file is updated with the new generated 
      //    and formatted content.
      zip.file('word/document.xml', docContent);

      // Generate the output file
      const outputFileName = `QUOTE-${data['COMPANY-NAME']}.docx`;
      const outputPath = path.join(__dirname, OUTPUT_FOLDER, outputFileName);
      // Generates the ZIP file from the data that has been loaded and/or modified in the zip object
      //    { type: 'node buffer' }: Generate the ZIP file as a node buffer instead of other formats 
      //                              such as a base64 string or Blob.
      //    A node buffer (Node.js Buffer) is a data structure used in Node.js to handle binary data. 
      //      It is essentially a region of memory allocated to temporarily store data while it is 
      //      being transferred between different parts of a program or between the program and its 
      //      input/output environments, such as files, networks, or databases.
      const outputBuffer = await zip.generateAsync({ type: 'nodebuffer' });

      // Write the output file
      //    outputBuffer: It is the content that will be written to the output file. In this case, 
      //      it is the buffer that contains the data of the generated document in binary format.
      await writeFile(outputPath, outputBuffer);
      console.log(`Document created: ${outputFileName}`);
    } catch (error) {
      console.error('Error creating document:', error);
    }
  })
  // The 'end' event is fired by the CSV file read stream (fs.createReadStream()) once the end of the file 
  //    has been reached.
  .on('end', () => {
    console.log('All documents are in process.');
  });
